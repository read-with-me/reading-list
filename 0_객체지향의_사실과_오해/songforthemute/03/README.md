## 03. 타입과 시스템

#### 추상화를 통한 복잡성 극복

> 진정한 의미에서 추상화란 현실에서 출발하여 불필요한 부분을 제거함으로써 사물의 본질을 드러내는 과정.
>
> 추상화의 목적은 복잡성을 극복하는 것으로, 이는 불필요한 부분을 무시함으로써 이루어짐.
>
> 추상화는 인간이 복잡한 현실을 단순화하기 위해 사용하는 가장 기본적인 인지 수단.
>
> 하지만 추상화는 목적에 따라 다르게 해석될 수 있으며, 의도와 다르게 사용되면 오도될 수 있음.
>
> 추상화의 수준, 이익, 가치는 목적에 의존적임.

#### 복잡성을 다루기 위한 두 차원의 추상화

> 구체적인 사물 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만듦.
>
> 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거하여 단순화함.

#### 객체와 객체지향 패러다임

> 객체지향 패러다임에서는 명확한 경계를 가진 구체적인 사람이나 사물을 객체라 일컫음.
>
> 객체지향의 중심에는 구체적이고 실제적인 객체가 존재하지만, 개별적으로 모든 객체를 다루기에는 인간의 인지 능력이 제한됨.
>
> 따라서 공통 특성을 기준으로 객체를 그룹화하여 단순화함.
>
> 객체들을 그룹화하기 위한 그릇을 개념(concept)이라고 부름.
>
> 개념을 통해 객체를 여러 그룹으로 분류(classification)할 수 있음.

#### 개념의 구성 요소

> 개념은 세 가지로 구성됨:
>
> 1.  심볼(symbol): 개념을 가리키는 이름이나 명칭.
> 2.  내연(intension): 개념의 정의를 나타내며, 이 정의를 통해 객체가 개념에 속하는지 확인 가능.
> 3.  외연(extension): 개념에 속하는 모든 객체의 집합.
>
> 개념은 객체 분류 방식에 대한 지침을 제공하지만, 더 중요한 것은 개념을 통해 객체를 분류할 수 있다는 사실.

#### 객체 분류와 개념의 적용

> 외연적 관점에서 개념을 적용함으로써 객체를 개념의 일원으로 포함시킴.
>
> 객체를 개념에 맞게 분류하는 것은 적용할 개념을 결정하는 작업과 같음.
>
> 객체의 분류는 적절한 분류 체계를 통해 개발자가 객체를 쉽게 찾고 조작할 수 있도록 도움.

#### 타입과 타입 시스템

> 타입(type)은 공통점을 기반으로 객체들을 묶기 위한 틀로, 개념과 유사하게 심볼, 내연, 외연으로 서술 가능.
>
> 타입 시스템은 메모리 안의 데이터를 적절하게 분류하고, 혼란을 방지하며, 데이터의 오사용을 방지하는 데 목적이 있음.
>
> 데이터 타입은 데이터를 어떻게 사용하고, 그에 대해 어떤 작업을 수행할 수 있는지를 결정함.

#### 객체와 데이터의 차이

> 객체는 데이터를 포함할 수 있지만, 행동이 중요하며, 데이터는 객체의 상태를 표현하는 데 사용됨.
>
> 객체의 핵심은 이웃 객체와의 협력을 위한 행동이며, 객체의 행동을 결정하는 것이 객체지향 설계의 핵심.
>
> 타입에 따라 객체를 분류하는 기준은 객체가 동일한 행동을 할 수 있는지에 있음.

#### 객체의 캡슐화

> 훌륭한 객체지향 설계는 행동만 외부에 제공하고, 데이터는 행동 뒤로 감춰야 하며, 이를 캡슐화라고 표현.
>
> 객체의 내부 표현 방식은 외부로부터 은닉되어야 하며, 객체는 자신에게 필요한 데이터를 외부 인터페이스 뒤로 감춤.

#### 책임-주도 설계

> 객체지향 설계에서는 객체가 외부에 제공해야 하는 책임을 먼저 고려하고, 그 후 책임을 수행하는 데 적합한 데이터를 결정함.
>
> 책임-주도 설계(Responsibility-Driven Design)는 데이터를 우선시하는 데이터-주도 설계(Data-Driven Design)의 한계를 극복하기 위해 개발됨.

#### 일반화와 특수화

> 객체들 사이의 관계는 일반화/특수화로 표현되며, 일반적인 객체는 특수한 객체보다 적은 행동을 가짐.
>
> 일반적인 타입은 슈퍼타입(Supertype), 특수한 타입은 서브타입(Subtype)으로 불림.
>
> 서브타입은 슈퍼타입의 행동과 호환성을 만족하며, 슈퍼타입을 대체할 수 있어야 함.

#### 정적 모델과 동적 모델

> 객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 통해 구현되며, 타입을 구현하는 보편적 방법임.
>
> 동적 모델은 객체의 상태 변화와 행동을 포착하고, 정적 모델은 객체의 타입을 묘사함.
>
> 클래스와 타입은 동일한 것이 아니며, 클래스는 타입을 구현하는 하나의 방법임.

#### 추상화를 통한 복잡성 극복

> 진정한 의미에서 추상화란 현실에서 출발하여 불필요한 부분을 제거함으로써 사물의 본질을 드러내는 과정.
>
> 추상화의 목적은 복잡성을 극복하는 것으로, 이는 불필요한 부분을 무시함으로써 이루어짐.
>
> 추상화는 인간이 복잡한 현실을 단순화하기 위해 사용하는 가장 기본적인 인지 수단.
>
> 하지만 추상화는 목적에 따라 다르게 해석될 수 있으며, 의도와 다르게 사용되면 오도될 수 있음.
>
> 추상화의 수준, 이익, 가치는 목적에 의존적임.

#### 복잡성을 다루기 위한 두 차원의 추상화

> 구체적인 사물 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만듦.
>
> 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거하여 단순화함.

#### 객체와 객체지향 패러다임

> 객체지향 패러다임에서는 명확한 경계를 가진 구체적인 사람이나 사물을 객체라 일컫음.
>
> 객체지향의 중심에는 구체적이고 실제적인 객체가 존재하지만, 개별적으로 모든 객체를 다루기에는 인간의 인지 능력이 제한됨.
>
> 따라서 공통 특성을 기준으로 객체를 그룹화하여 단순화함.
>
> 객체들을 그룹화하기 위한 그릇을 개념(concept)이라고 부름.
>
> 개념을 통해 객체를 여러 그룹으로 분류(classification)할 수 있음.

#### 개념의 구성 요소

> 개념은 세 가지로 구성됨:
>
> > 1.  심볼(symbol): 개념을 가리키는 이름이나 명칭.
> > 2.  내연(intension): 개념의 정의를 나타내며, 이 정의를 통해 객체가 개념에 속하는지 확인 가능.
> > 3.  외연(extension): 개념에 속하는 모든 객체의 집합.
>
> 개념은 객체 분류 방식에 대한 지침을 제공하지만, 더 중요한 것은 개념을 통해 객체를 분류할 수 있다는 사실.

#### 객체 분류와 개념의 적용

> 외연적 관점에서 개념을 적용함으로써 객체를 개념의 일원으로 포함시킴.
>
> 객체를 개념에 맞게 분류하는 것은 적용할 개념을 결정하는 작업과 같음.
>
> 객체의 분류는 적절한 분류 체계를 통해 개발자가 객체를 쉽게 찾고 조작할 수 있도록 도움.

#### 타입과 타입 시스템

> 타입(type)은 공통점을 기반으로 객체들을 묶기 위한 틀로, 개념과 유사하게 심볼, 내연, 외연으로 서술 가능.
>
> 타입 시스템은 메모리 안의 데이터를 적절하게 분류하고, 혼란을 방지하며, 데이터의 오사용을 방지하는 데 목적이 있음.
>
> 데이터 타입은 데이터를 어떻게 사용하고, 그에 대해 어떤 작업을 수행할 수 있는지를 결정함.

#### 객체와 데이터의 차이

> 객체는 데이터를 포함할 수 있지만, 행동이 중요하며, 데이터는 객체의 상태를 표현하는 데 사용됨.
>
> 객체의 핵심은 이웃 객체와의 협력을 위한 행동이며, 객체의 행동을 결정하는 것이 객체지향 설계의 핵심.
>
> 타입에 따라 객체를 분류하는 기준은 객체가 동일한 행동을 할 수 있는지에 있음.

#### 객체의 캡슐화

> 훌륭한 객체지향 설계는 행동만 외부에 제공하고, 데이터는 행동 뒤로 감춰야 하며, 이를 캡슐화라고 표현.
>
> 객체의 내부 표현 방식은 외부로부터 은닉되어야 하며, 객체는 자신에게 필요한 데이터를 외부 인터페이스 뒤로 감춤.

#### 책임-주도 설계

> 객체지향 설계에서는 객체가 외부에 제공해야 하는 책임을 먼저 고려하고, 그 후 책임을 수행하는 데 적합한 데이터를 결정함.
>
> 책임-주도 설계(Responsibility-Driven Design)는 데이터를 우선시하는 데이터-주도 설계(Data-Driven Design)의 한계를 극복하기 위해 개발됨.

#### 일반화와 특수화

> 객체들 사이의 관계는 일반화/특수화로 표현되며, 일반적인 객체는 특수한 객체보다 적은 행동을 가짐.
>
> 일반적인 타입은 슈퍼타입(Supertype), 특수한 타입은 서브타입(Subtype)으로 불림.
>
> 서브타입은 슈퍼타입의 행동과 호환성을 만족하며, 슈퍼타입을 대체할 수 있어야 함.

#### 정적 모델과 동적 모델

> 객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 통해 구현되며, 타입을 구현하는 보편적 방법임.
>
> 동적 모델은 객체의 상태 변화와 행동을 포착하고, 정적 모델은 객체의 타입을 묘사함.
>
> 클래스와 타입은 동일한 것이 아니며, 클래스는 타입을 구현하는 하나의 방법임.
